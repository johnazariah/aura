---
description: Executes a single workflow step
ragQueries:
  - "project structure build setup dotnet csproj solution"
tools:
  - file.read
  - file.write
  - file.modify
  - file.list
  - git.status
  - git.commit
  - git.branch
  - roslyn.validate_compilation
---
Execute this development step:

## Step
Name: {{stepName}}
Description: {{stepDescription}}

## Workflow Context
Issue: {{issueTitle}}
{{analysis}}

## Critical: Follow the Step Description Exactly

**Your task is ONLY what the step description says.** Do not jump ahead to later steps.

**CRITICAL: Path Format**
- Always use **RELATIVE paths** like `src/Aura.Foundation/Rag/PathNormalizer.cs`
- Do NOT include worktree folder names, branch names, or absolute paths
- Do NOT use paths like `workflow-add-xml.../src/...` - just use `src/...`
- Forward slashes work on all platforms

### Step Type Guidelines

If the step says **"Review"** or **"Analyze"** or **"Examine"**:
- **CRITICAL: Use file.read to read the actual source files mentioned in the step description**
- If a file path is mentioned (like `src/...` or `tests/...`), you MUST read it first
- Output an ANALYSIS with findings, not a finished product
- List what you found: gaps, issues, outdated content, missing sections
- Do NOT produce the final deliverable yet

If the step says **"Draft"** or **"Create"** or **"Write"** or **"Add"** or **"Integrate"** or **"Insert"**:
- If updating an existing file, first use **file.read** to read the current content
- If creating a NEW file, go straight to writing - don't try to read a file that doesn't exist
- Produce the actual content/code and **WRITE IT TO DISK**
- **CRITICAL: You MUST call file.write to create new files or file.modify to update existing files**
- Do NOT just output content in your response - you MUST use the file tools to write it
- Do NOT call "finish" until you have actually called file.write or file.modify
- The step is NOT complete until the file exists on disk with the content you created

**CRITICAL: File Not Found Handling**
- If file.read returns "file not found" for an EXISTING file you need to analyze:
  - The path in the step description may be wrong. Use `file.list` with recursive=true and pattern="*FileName*" to locate the actual file
  - Search for the file by name: `file.list` with path="src" recursive=true pattern="*GitTools*"
  - NEVER create placeholder files for files that should already exist
- Only use file.write to CREATE genuinely new files (like new test files you're adding)

If the step says **"Validate"** or **"Review draft"**:
- Output a review with specific feedback
- List what's good, what needs improvement, specific suggestions

If the step says **"Incorporate feedback"** or **"Finalize"**:
- Apply the changes from the review step
- Output the improved version
- **CRITICAL: You MUST call file.write or file.modify to save changes**

If the step says **"Commit"** or **"Apply"**:
- Output the final artifact ready for commit
- Include the exact file path and complete content
- **CRITICAL: You MUST call file.write or file.modify to save changes**

## General Instructions

**For analysis/review steps:**
- Use ONLY information from the provided RAG context
- Be specific: cite file names, line numbers, exact issues found
- Structure as: Current state - Issues found - Recommendations

**For documentation tasks:**
- Use ONLY information from the provided RAG context - do not invent file names, classes, or features
- Include specific package/project names, their exact purposes, and dependency relationships
- Reference real documentation files with their actual paths
- Include accurate build commands from the project's build system
- Mention technical details like frameworks, patterns, and performance characteristics when available

**For coding tasks:**
- **CRITICAL: Before writing any code, use file.read to read the source file(s) you're testing or modifying**
- If the step mentions a specific file path, READ IT FIRST with file.read
- Output complete file contents, not snippets
- Follow existing code patterns and conventions from the codebase
- Include necessary imports and dependencies
- Base your implementation on the ACTUAL code you read, not assumptions
- **CRITICAL: After writing C# code, you MUST call roslyn.validate_compilation with the project name (e.g., "Aura.Foundation.Tests") to verify it compiles**
- If roslyn.validate_compilation returns ANY errors, you MUST fix the code with file.modify and validate again
- Do NOT call git.commit or finish until roslyn.validate_compilation returns success with ZERO errors
- If roslyn.validate_compilation fails with "No solution file found", provide the full project path
- **CRITICAL: After compilation succeeds, you MUST call git.commit to commit your changes before finishing**
  - Use a descriptive commit message that summarizes what was created/changed
  - Example: `git.commit` with message "Add unit tests for DynamicExpression class"

**CRITICAL: All file paths are RELATIVE to your working directory**
- Paths in the context below (like `BrightSword.SwissKnife/StringExtensions.cs`) are RELATIVE paths
- When you call file.read, file.write, or file.modify, use these RELATIVE paths directly
- Do NOT prefix paths with absolute paths like `C:/work/...`
- Example: Use `file.read` with path `BrightSword.SwissKnife.Tests/StringExtensionsTests.cs`, NOT `C:/work/BrightSword/BrightSword.SwissKnife.Tests/StringExtensionsTests.cs`

**For test file creation (ANY step that creates a *Tests.cs file):**
- **MANDATORY FIRST STEP: Read an existing test file in the same test project BEFORE writing any code**
  - First find the test project: Use `file.list` with path=".", recursive=true, pattern="*Tests.csproj" to locate test projects
  - Then find existing tests: Use `file.list` in the test project directory with pattern="*Tests.cs"
  - Use `file.read` to read at least one existing test file AND the .csproj to see what packages are referenced
  - Learn: testing framework (xUnit uses [Fact]/[Theory], NUnit uses [Test]/[TestFixture]), assertion style, mocking library
- **CRITICAL**: Match the EXACT testing framework - if existing tests use `[Fact]`, you MUST use `[Fact]` not `[Test]`
- The source class you're testing may be STATIC - check the actual source code first
- Write REAL test implementations, not placeholder stubs like "// Add assertions here"
- Mock dependencies using the SAME mocking library as existing tests
- **If validation fails**, read the error messages carefully - they often indicate framework mismatches

**INCREMENTAL TEST WRITING (MANDATORY for testing steps):**
- Write tests ONE AT A TIME following this cycle:
  1. Write ONE test method
  2. Call `roslyn.validate_compilation` to verify it compiles
  3. If compilation fails, fix the error with `file.modify` and validate again
  4. Once it compiles, write the NEXT test method
  5. Repeat until all tests are written
- Do NOT write all tests at once then validate - this makes debugging harder
- If you're adding tests to an existing file, use `file.modify` to add one test at a time

**If information is missing:**
- Say "information not available in context" rather than guessing
- Be specific and technical, not generic
- Reference actual file paths from the RAG context