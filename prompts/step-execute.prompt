---
description: Executes a single workflow step
ragQueries:
  - "project structure build setup dotnet csproj solution"
tools:
  # File operations (basic)
  - file.read
  - file.write
  - file.modify
  - file.list
  - file.exists
  # Aura semantic tools (C# refactoring and generation - prefer these)
  - aura.refactor      # rename, change_signature, extract_interface, safe_delete, move_type_to_file
  - aura.generate      # tests, create_type, implement_interface, constructor, property, method
  - aura.validate      # get compilation/test commands
  # Roslyn semantic tools (C# - code analysis)
  - roslyn.list_projects
  - roslyn.list_classes
  - roslyn.get_class_info
  - roslyn.find_usages
  - roslyn.validate_compilation
  # Code graph tools (navigation)
  - graph.find_callers
  - graph.find_implementations
  - graph.get_type_members
  # Git operations
  - git.status
  - git.commit
  - git.branch
  # Validation and execution
  - code.validate
  - shell.execute
  - spawn_subagent
  # Language-specific tools (auto-selected based on project)
  - dotnet.build_until_success
  - dotnet.run_tests
  # Patterns (recipes for complex multi-step tasks)
  - pattern.list
  - pattern.load
---
Execute this development step:

## Step
Name: {{stepName}}
Description: {{stepDescription}}

{{#if revisionFeedback}}
## ⚠️ Revision Required
This step was previously completed but rejected. The reviewer provided this feedback:

> {{revisionFeedback}}

**Address this feedback specifically in your implementation.**
{{/if}}

## Workflow Context
Issue: {{issueTitle}}
{{analysis}}

## Critical: Follow the Step Description Exactly

**Your task is ONLY what the step description says.** Do not jump ahead to later steps.

**CRITICAL: Path Format**
- Always use **RELATIVE paths** like `src/Aura.Foundation/Rag/PathNormalizer.cs`
- Do NOT include worktree folder names, branch names, or absolute paths
- Do NOT use paths like `workflow-add-xml.../src/...` - just use `src/...`
- Forward slashes work on all platforms

### Tool Selection: Use Semantic Tools for C#

For **C# projects**, prefer Aura and Roslyn semantic tools over basic file manipulation:

| Task | Use This | NOT This |
|------|----------|----------|
| Rename symbol | `aura.refactor(operation: "rename")` | Find/replace across files |
| Add method to class | `aura.generate(operation: "method")` | `file.modify` |
| Add property to class | `aura.generate(operation: "property")` | `file.modify` |
| Create new C# type | `aura.generate(operation: "create_type")` | `file.write` |
| Generate tests | `aura.generate(operation: "tests")` | Manual test writing |
| Implement interface | `aura.generate(operation: "implement_interface")` | Manual stubs |
| Extract interface | `aura.refactor(operation: "extract_interface")` | Copy/paste |
| Understand a class | `roslyn.get_class_info` | `file.read` + manual parsing |
| Find all usages | `roslyn.find_usages` | `grep` patterns |
| List classes in project | `roslyn.list_classes` | `file.list` + guessing |
| Find implementations | `graph.find_implementations` | searching files |
| Validate code compiles | `code.validate` | `shell.execute dotnet build` |

**Aura Refactor Operations:**
- `rename` - Rename symbols with blast radius analysis (defaults to analyze mode)
- `change_signature` - Add/remove parameters from methods
- `extract_interface` - Extract interface from class
- `safe_delete` - Safely delete unused symbols
- `move_type_to_file` - Move type to its own file

**Aura Generate Operations:**
- `tests` - Generate test scaffolding with framework detection
- `create_type` - Create new class/record/struct/interface
- `implement_interface` - Implement interface methods
- `constructor` - Generate constructor
- `property` - Add property to class
- `method` - Add method to class

**When creating new C# files:**
1. Prefer `aura.generate(operation: "create_type")` for new classes/records/interfaces
2. Use `roslyn.list_classes` to see existing patterns in the namespace
3. Look at similar files with `roslyn.get_class_info` to match conventions
4. Validate with `code.validate` before finishing

**When writing tests:**
1. Prefer `aura.generate(operation: "tests", target: "ClassName", analyzeOnly: true)` to analyze testability
2. Then `aura.generate(operation: "tests", target: "ClassName")` to generate tests
3. For manual tests, use `roslyn.get_class_info` to understand the class under test
4. Include ALL required `using` statements (check existing test files for patterns)
5. Run `dotnet.run_tests` or `code.validate` to verify tests compile
6. **For complex test scenarios, load the pattern:** `pattern.load(name: "generate-tests", language: "csharp")`

### Using Patterns for Complex Tasks

Patterns are recipes for multi-step operations. Before starting a complex task, check if a pattern exists:

```
pattern.list()  // See available patterns
pattern.load(name: "generate-tests", language: "csharp")  // Load specific pattern
```

**Available patterns include:**
- `generate-tests` - Comprehensive test generation with proper imports and mocking
- `comprehensive-rename` - Rename a concept across the entire codebase

When a pattern is loaded, follow its step-by-step instructions.

### Step Type Guidelines

If the step says **"Review"** or **"Analyze"** or **"Examine"**:
- **CRITICAL: Use file.read to read the actual source files mentioned in the step description**
- If a file path is mentioned (like `src/...` or `tests/...`), you MUST read it first
- Output an ANALYSIS with findings, not a finished product
- List what you found: gaps, issues, outdated content, missing sections
- Do NOT produce the final deliverable yet

If the step says **"Draft"** or **"Create"** or **"Write"** or **"Add"** or **"Integrate"** or **"Insert"**:
- If updating an existing file, first use **file.read** to read the current content
- If creating a NEW file, go straight to writing - don't try to read a file that doesn't exist
- Produce the actual content/code and **WRITE IT TO DISK**
- **CRITICAL: You MUST call file.write to create new files or file.modify to update existing files**
- Do NOT just output content in your response - you MUST use the file tools to write it
- Do NOT call "finish" until you have actually called file.write or file.modify
- The step is NOT complete until the file exists on disk with the content you created

**CRITICAL: File Not Found Handling**
- If file.read returns "file not found" for an EXISTING file you need to analyze:
  - The path in the step description may be wrong. Use `file.list` with recursive=true and pattern="*FileName*" to locate the actual file
  - Search for the file by name: `file.list` with path="src" recursive=true pattern="*GitTools*"
  - NEVER create placeholder files for files that should already exist
- Only use file.write to CREATE genuinely new files (like new test files you're adding)

If the step says **"Validate"** or **"Review draft"**:
- Output a review with specific feedback
- List what's good, what needs improvement, specific suggestions

If the step says **"Incorporate feedback"** or **"Finalize"**:
- Apply the changes from the review step
- Output the improved version
- **CRITICAL: You MUST call file.write or file.modify to save changes**

If the step says **"Commit"** or **"Apply"**:
- Output the final artifact ready for commit
- Include the exact file path and complete content
- **CRITICAL: You MUST call file.write or file.modify to save changes**

## General Instructions

**For analysis/review steps:**
- Use ONLY information from the provided RAG context
- Be specific: cite file names, line numbers, exact issues found
- Structure as: Current state - Issues found - Recommendations

**For documentation tasks:**
- Use ONLY information from the provided RAG context - do not invent file names, classes, or features
- Include specific package/project names, their exact purposes, and dependency relationships
- Reference real documentation files with their actual paths
- Include accurate build commands from the project's build system
- Mention technical details like frameworks, patterns, and performance characteristics when available

**For coding tasks:**
- **CRITICAL: Before writing any code, use file.read to read the source file(s) you're testing or modifying**
- If the step mentions a specific file path, READ IT FIRST with file.read
- Output complete file contents, not snippets
- Follow existing code patterns and conventions from the codebase
- Include necessary imports and dependencies
- Base your implementation on the ACTUAL code you read, not assumptions
- **CRITICAL: Preserve EXACT indentation** - when adding code (like XML doc comments), match the indentation of surrounding code
  - If a method starts with 4 spaces, your `/// <summary>` must also start with 4 spaces
  - Every line of the XML doc block must have the same leading whitespace
- **CRITICAL: After writing code, you MUST call code.validate to verify it compiles**
  - This tool auto-detects language (C#, TypeScript, Python, Go, Rust) from project files
  - For C# projects, specify projectPath with the .csproj file for faster validation
  - Example: `code.validate` with projectPath="tests/Aura.Foundation.Tests/Aura.Foundation.Tests.csproj"
- If code.validate returns ANY errors, you MUST fix the code with file.modify and validate again
- **CRITICAL: The system will BLOCK you from finishing if you have unvalidated code changes**
- Do NOT call git.commit or finish until code.validate returns success with ZERO errors
- **CRITICAL: After compilation succeeds, you MUST call git.commit to commit your changes before finishing**
  - **FIRST**: Run `shell.execute` with command `dotnet format` to fix any formatting issues
  - Then use git.commit with a descriptive commit message that summarizes what was created/changed
  - Example: `git.commit` with message "Add unit tests for DynamicExpression class"

**CRITICAL: All file paths are RELATIVE to your working directory**
- Paths in the context below (like `BrightSword.SwissKnife/StringExtensions.cs`) are RELATIVE paths
- When you call file.read, file.write, or file.modify, use these RELATIVE paths directly
- Do NOT prefix paths with absolute paths like `C:/work/...`
- Example: Use `file.read` with path `BrightSword.SwissKnife.Tests/StringExtensionsTests.cs`, NOT `C:/work/BrightSword/BrightSword.SwissKnife.Tests/StringExtensionsTests.cs`

**For test file creation (ANY step that creates a *Tests.cs file):**
- **MANDATORY FIRST STEP: Read an existing test file in the same test project BEFORE writing any code**
  - First find the test project: Use `file.list` with path=".", recursive=true, pattern="*Tests.csproj" to locate test projects

## Sub-Agent Spawning

For complex subtasks, you can spawn isolated sub-agents using `spawn_subagent`:

**Use when:**
- A subtask is self-contained (code review, test generation, documentation)
- Context is filling up (approaching token limits)
- You need a "fresh perspective" on a problem

**Example:**
```json
{
  "agent": "code-review-agent",
  "task": "Review the test file I just created for coverage gaps",
  "maxSteps": 5
}
```

Do NOT spawn sub-agents for simple operations or when you're close to finishing.

  - Then find existing tests: Use `file.list` in the test project directory with pattern="*Tests.cs"
  - Use `file.read` to read at least one existing test file AND the .csproj to see what packages are referenced
  - Learn: testing framework (xUnit uses [Fact]/[Theory], NUnit uses [Test]/[TestFixture]), assertion style, mocking library
- **CRITICAL**: Match the EXACT testing framework - if existing tests use `[Fact]`, you MUST use `[Fact]` not `[Test]`
- The source class you're testing may be STATIC - check the actual source code first
- Write REAL test implementations, not placeholder stubs like "// Add assertions here"
- Mock dependencies using the SAME mocking library as existing tests
- **If validation fails**, read the error messages carefully - they often indicate framework mismatches

**INCREMENTAL TEST WRITING (MANDATORY for testing steps):**
- Write tests ONE AT A TIME following this cycle:
  1. Write ONE test method
  2. Call `code.validate` to verify it compiles
  3. If compilation fails, fix the error with `file.modify` and validate again
  4. Once it compiles, write the NEXT test method
  5. Repeat until all tests are written
- Do NOT write all tests at once then validate - this makes debugging harder
- If you're adding tests to an existing file, use `file.modify` to add one test at a time

**If information is missing:**
- Say "information not available in context" rather than guessing
- Be specific and technical, not generic
- Reference actual file paths from the RAG context
