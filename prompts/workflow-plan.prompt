---
description: Creates a focused execution plan with 3-6 actionable steps
---
Create an implementation plan for this development task.

## Issue Title
{{title}}

## Issue Description
{{description}}

## Analysis Context
{{enrichedContext}}

## Planning Guidelines

**CRITICAL: Create 3-6 focused, actionable steps. Not 10+.**

### Step Design Principles

1. **Each step should produce a concrete deliverable** (a file, a test result, a review)
2. **Combine related analysis into ONE step** - don't split "Review X", "Analyze X", "Examine X"
3. **Final step must be an ACTION** - "Write README.md", "Apply changes", "Commit code"
4. **Skip meta-steps** - No "solicit feedback", "validate with team", "implement CI checks"
5. **Include specific file paths** - If a step analyzes or modifies a file, include the full path (e.g., `src/Aura.Foundation/Tools/GitTools.cs`)

### Good vs Bad Examples

BAD (too many steps):
1. Review current README
2. Gather architecture docs
3. Gather build info
4. Gather contribution guidelines
5. Extract usage examples
6. Verify build commands
7. Draft structure
8. Write content
9. Format markdown
10. Cross-check accuracy
11. Get feedback
12. Finalize
13. Add CI validation

GOOD (focused):
1. Analyze current README and codebase (review) - Identify gaps, outdated content, missing sections
2. Draft updated README (documentation) - Write complete README based on analysis
3. Review and refine (review) - Check accuracy, formatting, completeness
4. Write final README.md (documentation) - Output the final file content ready to save

### Example JSON Output for C# Codebase

```json
[
  {"name": "Analyze source code", "capability": "review", "language": "csharp", "wave": 1, "description": "Review the C# source files"},
  {"name": "Write unit tests", "capability": "testing", "language": "csharp", "wave": 2, "description": "Create xUnit tests"},
  {"name": "Run and validate tests", "capability": "testing", "language": "csharp", "wave": 3, "description": "Execute tests and verify"}
]
```

### For Pattern-Following Tasks (creating new components like existing ones)
- Wave 1: Analyze existing patterns (understand the model)
- Wave 1: Create interfaces/models (foundation types)
- Wave 2: Create implementations (services, repositories)
- Wave 3: Create integration points (controllers, endpoints)
- Wave 3: Write unit tests

### For Documentation Tasks
- Step 1: Analyze (what exists, what's missing)
- Step 2: Draft (write the content)
- Step 3: Review (check quality)
- Step 4: Finalize (output the file)

### For Coding Tasks
- Step 1: Understand (read relevant code, identify changes) - **Include specific file paths to read**
- Step 2: Implement (write the code)
- Step 3: Validate (run tests, check compilation)
- Step 4: Finalize (apply changes)

### For Test Writing Tasks
- Step 1: Analyze the source file (e.g., "Read and analyze src/Module/Class.cs") - **Use file.read on the exact file**
- Step 2: Create test infrastructure (test project, mocks)
- Step 3: Write unit tests (based on actual API from step 1)
- Step 4: Run and validate tests

## Available Capabilities
- coding: Code generation and implementation
- testing: Unit and integration test creation
- review: Code review and quality checks
- documentation: README, API docs, comments
- fixing: Build error and test failure fixing

## Languages
Detect the primary language from the Analysis Context above (look for file extensions, frameworks, or explicit mentions):
- .cs files, C#, .NET, ASP.NET → "csharp"
- .ts files, TypeScript, Angular, React → "typescript"  
- .js files, JavaScript, Node.js → "javascript"
- .py files, Python, Django, Flask → "python"
- .go files, Go, Golang → "go"
- .rs files, Rust, Cargo → "rust"
- .java files, Java, Spring → "java"

**IMPORTANT**: If the codebase uses a specific language, include `language` on ALL coding/testing steps. This ensures the correct language-specialist agent is assigned.

## Wave Assignment (for Parallel Execution)

Steps in the SAME wave run in PARALLEL. Steps in LATER waves wait for earlier waves to complete.

**Wave Assignment Rules:**
- **Wave 1**: Steps that have NO dependencies (can run immediately)
  - Creating interfaces/base types
  - Analysis/review steps
  - Independent file creation
- **Wave 2**: Steps that DEPEND on Wave 1 outputs
  - Implementations that need interfaces from Wave 1
  - Tests that need classes from Wave 1
- **Wave 3**: Steps that DEPEND on Wave 2 outputs
  - Controllers/endpoints that need services from Wave 2
  - Integration between components

**Example Wave Assignment:**
```json
[
  {"name": "Create IOrderService", "capability": "coding", "language": "csharp", "wave": 1, "description": "Create interface"},
  {"name": "Create Order model", "capability": "coding", "language": "csharp", "wave": 1, "description": "Create model class"},
  {"name": "Implement OrderService", "capability": "coding", "language": "csharp", "wave": 2, "description": "Implement the interface"},
  {"name": "Create OrdersController", "capability": "coding", "language": "csharp", "wave": 3, "description": "Create REST controller"}
]
```

## Output Format

Return a JSON array with 3-6 steps. Each step:
- name: Short actionable name (string, required)
- capability: One of: coding, testing, review, documentation, fixing (required)
- language: Programming language detected from context (REQUIRED for coding/testing steps - e.g., "csharp", "python", "typescript")
- wave: Execution wave number 1-3 (required) - Steps in same wave run in parallel, later waves wait
- description: What this step produces/accomplishes (optional)

**FINAL CHECK before responding**: 
1. Did you include `"language": "csharp"` (or the detected language) on every coding and testing step?
2. Did you assign proper `"wave"` values so dependent steps run AFTER their dependencies?

Return ONLY a valid JSON array, no markdown code blocks or other text.

