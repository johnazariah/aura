# Terraform Language Configuration
# Complete definition - tools, prompt, best practices all in one file

language:
  id: terraform
  name: Terraform
  extensions: [".tf", ".tfvars"]
  projectFiles: ["main.tf", "versions.tf", "terraform.tfstate"]

capabilities:
  - terraform-coding
  - coding
  - infrastructure-as-code

priority: 10

agent:
  provider: ollama
  model: qwen2.5-coder:14b
  temperature: 0.1
  maxSteps: 15

tools:
  init:
    id: terraform.init
    name: Initialize Terraform
    command: terraform
    args: ["init"]
    description: "Initialize Terraform working directory, download providers"
    categories: [terraform, initialization]
    requiresConfirmation: false

  validate:
    id: terraform.validate
    name: Validate Terraform
    command: terraform
    args: ["validate"]
    description: "Validate Terraform configuration syntax"
    categories: [terraform, validation]
    requiresConfirmation: false
    outputParsers:
      errors:
        type: lineMatch
        pattern: "Error:"
        ignoreCase: false

  plan:
    id: terraform.plan
    name: Plan Terraform Changes
    command: terraform
    args: ["plan"]
    description: "Preview changes Terraform will make to infrastructure"
    categories: [terraform, planning]
    requiresConfirmation: false

  apply:
    id: terraform.apply
    name: Apply Terraform Changes
    command: terraform
    args: ["apply", "-auto-approve"]
    description: "Apply Terraform changes to infrastructure"
    categories: [terraform, deployment]
    requiresConfirmation: true

  format:
    id: terraform.fmt
    name: Format Terraform Code
    command: terraform
    args: ["fmt"]
    description: "Format Terraform files to canonical style"
    categories: [terraform, formatting]
    requiresConfirmation: true

  format_check:
    id: terraform.fmt_check
    name: Check Terraform Formatting
    command: terraform
    args: ["fmt", "-check"]
    description: "Check if Terraform files are formatted"
    categories: [terraform, formatting]
    requiresConfirmation: false

  lint:
    id: terraform.lint
    name: Lint Terraform Code
    command: tflint
    args: []
    description: "Lint Terraform files with TFLint"
    categories: [terraform, linting]
    requiresConfirmation: false

  security:
    id: terraform.security
    name: Security Scan Terraform
    command: tfsec
    args: ["."]
    description: "Security scan Terraform files with tfsec"
    categories: [terraform, security]
    requiresConfirmation: false

  state_list:
    id: terraform.state_list
    name: List Terraform State
    command: terraform
    args: ["state", "list"]
    description: "List resources in Terraform state"
    categories: [terraform, state]
    requiresConfirmation: false

  output:
    id: terraform.output
    name: Show Terraform Outputs
    command: terraform
    args: ["output", "-json"]
    description: "Show Terraform outputs in JSON format"
    categories: [terraform, output]
    requiresConfirmation: false
    outputParsers:
      result:
        type: json
        path: "$"

prompt:
  workflow: |
    Follow this workflow:
    1. **Understand**: Read relevant .tf files, understand the infrastructure
    2. **Plan**: Think through the resources and their dependencies
    3. **Implement**: Make targeted edits using file.modify or file.write
    4. **Format**: Use terraform.fmt to ensure proper formatting
    5. **Validate**: Use terraform.validate to check syntax
    6. **Lint**: Use terraform.lint (TFLint) for best practices
    7. **Security**: Use terraform.security (tfsec) for security issues
    8. **Plan**: Use terraform.plan to preview changes

  bestPractices: |
    - Use modules for reusable infrastructure components
    - Store state remotely (S3, Azure Blob, GCS) for team collaboration
    - Use workspaces for environment separation (dev, staging, prod)
    - Lock provider versions in versions.tf
    - Use variables.tf for input variables, outputs.tf for outputs
    - Use locals for computed values and to reduce repetition
    - Name resources descriptively: resource "type" "descriptive_name"
    - Use data sources to reference existing infrastructure
    - Use count or for_each for creating multiple similar resources
    - Run terraform plan before apply to review changes
    - Use terraform fmt to maintain consistent formatting
    - Keep secrets out of .tf files - use variables or secret managers

  syntaxReminders: |
    - Provider: `provider "aws" { region = "us-west-2" }`
    - Resource: `resource "aws_instance" "web" { ami = "ami-123" instance_type = "t2.micro" }`
    - Variable: `variable "region" { type = string default = "us-west-2" }`
    - Output: `output "instance_ip" { value = aws_instance.web.public_ip }`
    - Local: `locals { common_tags = { Environment = "prod" } }`
    - Data source: `data "aws_ami" "ubuntu" { most_recent = true ... }`
    - Module: `module "vpc" { source = "./modules/vpc" cidr = "10.0.0.0/16" }`
    - Count: `resource "aws_instance" "web" { count = 3 ... }`
    - For each: `resource "aws_instance" "web" { for_each = toset(["a", "b"]) ... }`
    - Conditional: `count = var.create_instance ? 1 : 0`
    - String interpolation: `"Hello, ${var.name}!"`
    - Heredoc: `<<-EOT ... EOT`
    - Dynamic block: `dynamic "ingress" { for_each = var.ports content { ... } }`

  projectStructure: |
    - main.tf contains primary resource definitions
    - variables.tf defines input variables
    - outputs.tf defines outputs
    - versions.tf locks provider versions
    - terraform.tfvars provides variable values (gitignored for secrets)
    - modules/ contains reusable modules
