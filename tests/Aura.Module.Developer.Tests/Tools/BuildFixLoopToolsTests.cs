// <auto-generated>
// This file was generated by Aura Test Generator.
// </auto-generated>

#nullable enable

using Xunit;
using NSubstitute;
using FluentAssertions;
using Aura.Module.Developer.Tools;
using Aura.Foundation.Agents;
using Aura.Foundation.Shell;
using Aura.Foundation.Tools;
using Microsoft.Extensions.Logging.Abstractions;

namespace Aura.Module.Developer.Tools.Tests;

public class BuildFixLoopToolsTests
{
    [Fact]
    public void RegisterBuildFixLoopTools_WhenCalled_RegistersToolsInRegistry()
    {
        // Arrange
        var registry = Substitute.For<IToolRegistry>();
        var processRunner = Substitute.For<IProcessRunner>();
        var agentRegistry = Substitute.For<IAgentRegistry>();
        var logger = NullLogger.Instance;

        // Act
        BuildFixLoopTools.RegisterBuildFixLoopTools(registry, processRunner, agentRegistry, logger);

        // Assert - should register at least one tool
        registry.Received().RegisterTool(Arg.Any<ToolDefinition>());
    }

    [Fact]
    public void RegisterBuildFixLoopTools_RegistersDotnetBuildUntilSuccessTool()
    {
        // Arrange
        var registry = Substitute.For<IToolRegistry>();
        var processRunner = Substitute.For<IProcessRunner>();
        var agentRegistry = Substitute.For<IAgentRegistry>();
        var logger = NullLogger.Instance;

        // Act
        BuildFixLoopTools.RegisterBuildFixLoopTools(registry, processRunner, agentRegistry, logger);

        // Assert - should register the dotnet.build_until_success tool
        registry.Received().RegisterTool(Arg.Is<ToolDefinition>(t => t.ToolId == "dotnet.build_until_success"));
    }

    [Fact]
    public void RegisterBuildFixLoopTools_RegistersCargoBuildUntilSuccessTool()
    {
        // Arrange
        var registry = Substitute.For<IToolRegistry>();
        var processRunner = Substitute.For<IProcessRunner>();
        var agentRegistry = Substitute.For<IAgentRegistry>();
        var logger = NullLogger.Instance;

        // Act
        BuildFixLoopTools.RegisterBuildFixLoopTools(registry, processRunner, agentRegistry, logger);

        // Assert
        registry.Received().RegisterTool(Arg.Is<ToolDefinition>(t => t.ToolId == "cargo.build_until_success"));
    }

    [Fact]
    public void RegisterBuildFixLoopTools_RegistersNpmBuildUntilSuccessTool()
    {
        // Arrange
        var registry = Substitute.For<IToolRegistry>();
        var processRunner = Substitute.For<IProcessRunner>();
        var agentRegistry = Substitute.For<IAgentRegistry>();
        var logger = NullLogger.Instance;

        // Act
        BuildFixLoopTools.RegisterBuildFixLoopTools(registry, processRunner, agentRegistry, logger);

        // Assert
        registry.Received().RegisterTool(Arg.Is<ToolDefinition>(t => t.ToolId == "npm.build_until_success"));
    }

    [Fact]
    public void RegisterBuildFixLoopTools_RegistersExactly3Tools()
    {
        // Arrange
        var registry = Substitute.For<IToolRegistry>();
        var processRunner = Substitute.For<IProcessRunner>();
        var agentRegistry = Substitute.For<IAgentRegistry>();
        var logger = NullLogger.Instance;

        // Act
        BuildFixLoopTools.RegisterBuildFixLoopTools(registry, processRunner, agentRegistry, logger);

        // Assert
        registry.Received(3).RegisterTool(Arg.Any<ToolDefinition>());
    }

    [Fact]
    public void RegisterBuildFixLoopTools_AllToolsHaveHandlers()
    {
        // Arrange
        var capturedTools = new List<ToolDefinition>();
        var registry = Substitute.For<IToolRegistry>();
        registry.When(r => r.RegisterTool(Arg.Any<ToolDefinition>()))
            .Do(ci => capturedTools.Add(ci.Arg<ToolDefinition>()));

        var processRunner = Substitute.For<IProcessRunner>();
        var agentRegistry = Substitute.For<IAgentRegistry>();
        var logger = NullLogger.Instance;

        // Act
        BuildFixLoopTools.RegisterBuildFixLoopTools(registry, processRunner, agentRegistry, logger);

        // Assert
        capturedTools.Should().HaveCount(3);
        capturedTools.Should().AllSatisfy(t => t.Handler.Should().NotBeNull());
    }

    [Fact]
    public void RegisterBuildFixLoopTools_AllToolsRequireConfirmation()
    {
        // Arrange - build-fix tools modify files so should require confirmation
        var capturedTools = new List<ToolDefinition>();
        var registry = Substitute.For<IToolRegistry>();
        registry.When(r => r.RegisterTool(Arg.Any<ToolDefinition>()))
            .Do(ci => capturedTools.Add(ci.Arg<ToolDefinition>()));

        var processRunner = Substitute.For<IProcessRunner>();
        var agentRegistry = Substitute.For<IAgentRegistry>();
        var logger = NullLogger.Instance;

        // Act
        BuildFixLoopTools.RegisterBuildFixLoopTools(registry, processRunner, agentRegistry, logger);

        // Assert
        capturedTools.Should().HaveCount(3);
        capturedTools.Should().AllSatisfy(t => t.RequiresConfirmation.Should().BeTrue());
    }

    [Fact]
    public void RegisterBuildFixLoopTools_AllToolsHaveInputSchemas()
    {
        // Arrange
        var capturedTools = new List<ToolDefinition>();
        var registry = Substitute.For<IToolRegistry>();
        registry.When(r => r.RegisterTool(Arg.Any<ToolDefinition>()))
            .Do(ci => capturedTools.Add(ci.Arg<ToolDefinition>()));

        var processRunner = Substitute.For<IProcessRunner>();
        var agentRegistry = Substitute.For<IAgentRegistry>();
        var logger = NullLogger.Instance;

        // Act
        BuildFixLoopTools.RegisterBuildFixLoopTools(registry, processRunner, agentRegistry, logger);

        // Assert
        capturedTools.Should().HaveCount(3);
        capturedTools.Should().AllSatisfy(t =>
        {
            t.InputSchema.Should().NotBeNullOrEmpty();
            t.InputSchema.Should().Contain("maxIterations");
        });
    }

    [Fact]
    public void RegisterBuildFixLoopTools_DotnetToolHasProjectPathProperty()
    {
        // Arrange
        var capturedTools = new List<ToolDefinition>();
        var registry = Substitute.For<IToolRegistry>();
        registry.When(r => r.RegisterTool(Arg.Any<ToolDefinition>()))
            .Do(ci => capturedTools.Add(ci.Arg<ToolDefinition>()));

        var processRunner = Substitute.For<IProcessRunner>();
        var agentRegistry = Substitute.For<IAgentRegistry>();
        var logger = NullLogger.Instance;

        // Act
        BuildFixLoopTools.RegisterBuildFixLoopTools(registry, processRunner, agentRegistry, logger);

        // Assert
        var dotnetTool = capturedTools.FirstOrDefault(t => t.ToolId == "dotnet.build_until_success");
        dotnetTool.Should().NotBeNull();
        dotnetTool!.InputSchema.Should().Contain("projectPath");
    }

    [Fact]
    public void RegisterBuildFixLoopTools_NpmToolHasBuildScriptProperty()
    {
        // Arrange
        var capturedTools = new List<ToolDefinition>();
        var registry = Substitute.For<IToolRegistry>();
        registry.When(r => r.RegisterTool(Arg.Any<ToolDefinition>()))
            .Do(ci => capturedTools.Add(ci.Arg<ToolDefinition>()));

        var processRunner = Substitute.For<IProcessRunner>();
        var agentRegistry = Substitute.For<IAgentRegistry>();
        var logger = NullLogger.Instance;

        // Act
        BuildFixLoopTools.RegisterBuildFixLoopTools(registry, processRunner, agentRegistry, logger);

        // Assert
        var npmTool = capturedTools.FirstOrDefault(t => t.ToolId == "npm.build_until_success");
        npmTool.Should().NotBeNull();
        npmTool!.InputSchema.Should().Contain("buildScript");
    }

    [Fact]
    public void RegisterBuildFixLoopTools_ToolsHaveCorrectCategories()
    {
        // Arrange
        var capturedTools = new List<ToolDefinition>();
        var registry = Substitute.For<IToolRegistry>();
        registry.When(r => r.RegisterTool(Arg.Any<ToolDefinition>()))
            .Do(ci => capturedTools.Add(ci.Arg<ToolDefinition>()));

        var processRunner = Substitute.For<IProcessRunner>();
        var agentRegistry = Substitute.For<IAgentRegistry>();
        var logger = NullLogger.Instance;

        // Act
        BuildFixLoopTools.RegisterBuildFixLoopTools(registry, processRunner, agentRegistry, logger);

        // Assert
        var dotnetTool = capturedTools.First(t => t.ToolId == "dotnet.build_until_success");
        dotnetTool.Categories.Should().Contain("dotnet");
        dotnetTool.Categories.Should().Contain("build");

        var cargoTool = capturedTools.First(t => t.ToolId == "cargo.build_until_success");
        cargoTool.Categories.Should().Contain("rust");

        var npmTool = capturedTools.First(t => t.ToolId == "npm.build_until_success");
        npmTool.Categories.Should().Contain("typescript");
    }

    // ========================================================================
    // ParseBuildErrors Tests (internal method)
    // ========================================================================
    // Note: The current implementation applies all regex patterns to all inputs,
    // which can result in duplicates when patterns overlap (e.g., MSBuild and TS patterns).

    [Fact]
    public void ParseBuildErrors_WithMSBuildError_ParsesCorrectly()
    {
        // Arrange - typical MSBuild error format (no indentation to match ^ anchor)
        // Note: warnings don't match the TS pattern (which only matches "error")
        var output = @"C:\src\MyProject\Program.cs(10,15): warning CS1002: ; expected";

        // Act
        var errors = BuildFixLoopTools.ParseBuildErrors(output, "csharp");

        // Assert - only matches MSBuild pattern (TS pattern requires "error", not "warning")
        errors.Should().HaveCount(1);
        var error = errors[0];
        error.FilePath.Should().Be(@"C:\src\MyProject\Program.cs");
        error.Line.Should().Be(10);
        error.Column.Should().Be(15);
        error.Code.Should().Be("CS1002");
        error.Message.Should().Be("; expected");
        error.Severity.Should().Be("warning");
    }

    [Fact]
    public void ParseBuildErrors_WithMSBuildWarning_ParsesWithCorrectSeverity()
    {
        // Arrange
        var output = @"C:\src\MyProject\Program.cs(5,1): warning CS0168: The variable 'x' is declared but never used";

        // Act
        var errors = BuildFixLoopTools.ParseBuildErrors(output, "csharp");

        // Assert
        errors.Should().HaveCount(1);
        errors[0].Severity.Should().Be("warning");
        errors[0].Code.Should().Be("CS0168");
    }

    [Fact]
    public void ParseBuildErrors_WithMSBuildErrorAndWarningMix_ParsesAll()
    {
        // Arrange - warnings only match MSBuild, errors match both MSBuild and TS
        var output = @"C:\src\Program.cs(10,15): warning CS1002: ; expected
C:\src\Other.cs(5,1): warning CS0168: Variable unused";

        // Act
        var errors = BuildFixLoopTools.ParseBuildErrors(output, "csharp");

        // Assert - only 2 warnings (no duplicates since TS pattern requires "error")
        errors.Should().HaveCount(2);
        errors.Should().OnlyContain(e => e.Severity == "warning");
    }

    [Fact]
    public void ParseBuildErrors_WithRustError_ParsesCorrectly()
    {
        // Arrange - typical Rust/Cargo error format
        var output = "error[E0425]: cannot find value `foo` in this scope --> src/main.rs:10:5";

        // Act
        var errors = BuildFixLoopTools.ParseBuildErrors(output, "rust");

        // Assert
        errors.Should().HaveCount(1);
        var error = errors[0];
        error.FilePath.Should().Be("src/main.rs");
        error.Line.Should().Be(10);
        error.Column.Should().Be(5);
        error.Code.Should().Be("E0425");
        error.Message.Should().Contain("cannot find value");
        error.Severity.Should().Be("error");
    }

    [Fact]
    public void ParseBuildErrors_WithTypeScriptError_MatchesBothPatterns()
    {
        // Arrange - TypeScript format matches both MSBuild and TS patterns
        var output = "src/index.ts(15,10): error TS2304: Cannot find name 'foo'.";

        // Act
        var errors = BuildFixLoopTools.ParseBuildErrors(output, "typescript");

        // Assert - matches both MSBuild and TS patterns (known behavior)
        errors.Should().HaveCount(2);
        errors.Should().OnlyContain(e => e.Code == "TS2304");
    }

    [Fact]
    public void ParseBuildErrors_WithNoErrors_ReturnsEmptyList()
    {
        // Arrange
        var output = @"Build succeeded.
0 Warning(s)
0 Error(s)";

        // Act
        var errors = BuildFixLoopTools.ParseBuildErrors(output, "csharp");

        // Assert
        errors.Should().BeEmpty();
    }

    [Fact]
    public void ParseBuildErrors_WithEmptyOutput_ReturnsEmptyList()
    {
        // Act
        var errors = BuildFixLoopTools.ParseBuildErrors("", "csharp");

        // Assert
        errors.Should().BeEmpty();
    }
}
