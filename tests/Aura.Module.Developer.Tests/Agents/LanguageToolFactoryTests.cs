// <auto-generated>
// This file was generated by Aura Test Generator and enhanced manually.
// </auto-generated>

#nullable enable

using Xunit;
using NSubstitute;
using FluentAssertions;
using Aura.Module.Developer.Agents;
using Aura.Foundation.Shell;
using Aura.Foundation.Tools;
using Microsoft.Extensions.Logging.Abstractions;

namespace Aura.Module.Developer.Agents.Tests;

public class LanguageToolFactoryTests
{
    [Fact]
    public void RegisterToolsFromConfig_WithEmptyConfig_ReturnsEmptyList()
    {
        // Arrange
        var registry = Substitute.For<IToolRegistry>();
        var processRunner = Substitute.For<IProcessRunner>();
        var config = new LanguageConfig
        {
            Language = new LanguageMetadata { Id = "test", Name = "Test" }
        };
        var logger = NullLogger.Instance;

        // Act
        var result = LanguageToolFactory.RegisterToolsFromConfig(registry, processRunner, config, logger);

        // Assert
        result.Should().NotBeNull();
        result.Should().BeEmpty(); // No tools defined in config
    }

    [Fact]
    public void RegisterToolsFromConfig_WithToolDefinition_RegistersTool()
    {
        // Arrange
        var registry = Substitute.For<IToolRegistry>();
        var processRunner = Substitute.For<IProcessRunner>();
        var config = new LanguageConfig
        {
            Language = new LanguageMetadata { Id = "python", Name = "Python" },
            Tools = new Dictionary<string, ToolConfig>
            {
                ["format"] = new ToolConfig
                {
                    Id = "python_format",
                    Description = "Format Python code",
                    Command = "black",
                    Args = ["{file}"]
                }
            }
        };
        var logger = NullLogger.Instance;

        // Act
        var result = LanguageToolFactory.RegisterToolsFromConfig(registry, processRunner, config, logger);

        // Assert
        result.Should().NotBeNull();
        result.Should().ContainSingle();
        result[0].Should().Be("python_format");
    }

    [Fact]
    public void RegisterToolsFromConfig_WithExistingTool_SkipsRegistration()
    {
        // Arrange
        var registry = Substitute.For<IToolRegistry>();
        registry.HasTool("python_format").Returns(true);
        var processRunner = Substitute.For<IProcessRunner>();
        var config = new LanguageConfig
        {
            Language = new LanguageMetadata { Id = "python", Name = "Python" },
            Tools = new Dictionary<string, ToolConfig>
            {
                ["format"] = new ToolConfig
                {
                    Id = "python_format",
                    Description = "Format Python code",
                    Command = "black",
                    Args = ["{file}"]
                }
            }
        };
        var logger = NullLogger.Instance;

        // Act
        var result = LanguageToolFactory.RegisterToolsFromConfig(registry, processRunner, config, logger);

        // Assert
        result.Should().BeEmpty(); // Skipped because tool already exists
        registry.DidNotReceive().RegisterTool(Arg.Any<ToolDefinition>());
    }

    [Fact]
    public void RegisterToolsFromConfig_WithMultipleTools_RegistersAllNewTools()
    {
        // Arrange
        var registry = Substitute.For<IToolRegistry>();
        registry.HasTool("python_format").Returns(true); // Existing
        registry.HasTool("python_lint").Returns(false); // New
        registry.HasTool("python_test").Returns(false); // New
        var processRunner = Substitute.For<IProcessRunner>();
        var config = new LanguageConfig
        {
            Language = new LanguageMetadata { Id = "python", Name = "Python" },
            Tools = new Dictionary<string, ToolConfig>
            {
                ["format"] = new ToolConfig { Id = "python_format", Command = "black" },
                ["lint"] = new ToolConfig { Id = "python_lint", Command = "ruff" },
                ["test"] = new ToolConfig { Id = "python_test", Command = "pytest" }
            }
        };
        var logger = NullLogger.Instance;

        // Act
        var result = LanguageToolFactory.RegisterToolsFromConfig(registry, processRunner, config, logger);

        // Assert
        result.Should().HaveCount(2);
        result.Should().Contain("python_lint");
        result.Should().Contain("python_test");
        result.Should().NotContain("python_format");
    }

    [Fact]
    public void RegisterToolsFromConfig_SetsToolMetadataCorrectly()
    {
        // Arrange
        ToolDefinition? capturedTool = null;
        var registry = Substitute.For<IToolRegistry>();
        registry.When(r => r.RegisterTool(Arg.Any<ToolDefinition>()))
            .Do(ci => capturedTool = ci.Arg<ToolDefinition>());
        var processRunner = Substitute.For<IProcessRunner>();
        var config = new LanguageConfig
        {
            Language = new LanguageMetadata { Id = "python", Name = "Python" },
            Tools = new Dictionary<string, ToolConfig>
            {
                ["format"] = new ToolConfig
                {
                    Id = "python_format",
                    Name = "Format Python",
                    Description = "Format Python code with Black",
                    Command = "black",
                    Categories = ["formatting", "code-quality"],
                    RequiresConfirmation = true
                }
            }
        };
        var logger = NullLogger.Instance;

        // Act
        LanguageToolFactory.RegisterToolsFromConfig(registry, processRunner, config, logger);

        // Assert
        capturedTool.Should().NotBeNull();
        capturedTool!.ToolId.Should().Be("python_format");
        capturedTool.Name.Should().Be("Format Python");
        capturedTool.Description.Should().Be("Format Python code with Black");
        capturedTool.Categories.Should().Contain("formatting");
        capturedTool.Categories.Should().Contain("code-quality");
        capturedTool.RequiresConfirmation.Should().BeTrue();
    }

    [Fact]
    public void RegisterToolsFromConfig_WithNoName_UsesIdAsName()
    {
        // Arrange
        ToolDefinition? capturedTool = null;
        var registry = Substitute.For<IToolRegistry>();
        registry.When(r => r.RegisterTool(Arg.Any<ToolDefinition>()))
            .Do(ci => capturedTool = ci.Arg<ToolDefinition>());
        var processRunner = Substitute.For<IProcessRunner>();
        var config = new LanguageConfig
        {
            Language = new LanguageMetadata { Id = "python", Name = "Python" },
            Tools = new Dictionary<string, ToolConfig>
            {
                ["format"] = new ToolConfig
                {
                    Id = "python_format",
                    Command = "black"
                    // No Name specified
                }
            }
        };
        var logger = NullLogger.Instance;

        // Act
        LanguageToolFactory.RegisterToolsFromConfig(registry, processRunner, config, logger);

        // Assert
        capturedTool.Should().NotBeNull();
        capturedTool!.Name.Should().Be("python_format");
    }

    [Fact]
    public void RegisterToolsFromConfig_WithNoDescription_GeneratesDefault()
    {
        // Arrange
        ToolDefinition? capturedTool = null;
        var registry = Substitute.For<IToolRegistry>();
        registry.When(r => r.RegisterTool(Arg.Any<ToolDefinition>()))
            .Do(ci => capturedTool = ci.Arg<ToolDefinition>());
        var processRunner = Substitute.For<IProcessRunner>();
        var config = new LanguageConfig
        {
            Language = new LanguageMetadata { Id = "python", Name = "Python" },
            Tools = new Dictionary<string, ToolConfig>
            {
                ["format"] = new ToolConfig
                {
                    Id = "python_format",
                    Command = "black"
                    // No Description specified
                }
            }
        };
        var logger = NullLogger.Instance;

        // Act
        LanguageToolFactory.RegisterToolsFromConfig(registry, processRunner, config, logger);

        // Assert
        capturedTool.Should().NotBeNull();
        capturedTool!.Description.Should().Be("Execute black");
    }

    [Fact]
    public async Task RegisterToolsFromConfig_ToolHandler_ExecutesCommand()
    {
        // Arrange
        ToolDefinition? capturedTool = null;
        var registry = Substitute.For<IToolRegistry>();
        registry.When(r => r.RegisterTool(Arg.Any<ToolDefinition>()))
            .Do(ci => capturedTool = ci.Arg<ToolDefinition>());
        var processRunner = Substitute.For<IProcessRunner>();
        processRunner.RunAsync(
            Arg.Any<string>(),
            Arg.Any<string[]>(),
            Arg.Any<ProcessOptions>(),
            Arg.Any<CancellationToken>())
            .Returns(Task.FromResult(new ProcessResult
            {
                ExitCode = 0,
                StandardOutput = "Formatted 1 file",
                StandardError = string.Empty
            }));
        var config = new LanguageConfig
        {
            Language = new LanguageMetadata { Id = "python", Name = "Python" },
            Tools = new Dictionary<string, ToolConfig>
            {
                ["format"] = new ToolConfig
                {
                    Id = "python_format",
                    Command = "black",
                    Args = ["--quiet"]
                }
            }
        };
        var logger = NullLogger.Instance;

        // Act
        LanguageToolFactory.RegisterToolsFromConfig(registry, processRunner, config, logger);

        // Assert handler executes correctly
        capturedTool.Should().NotBeNull();
        var input = new ToolInput { ToolId = "python_format" };
        var result = await capturedTool!.Handler(input, CancellationToken.None);

        result.Success.Should().BeTrue();
        await processRunner.Received(1).RunAsync(
            "black",
            Arg.Is<string[]>(args => args.Contains("--quiet")),
            Arg.Any<ProcessOptions>(),
            Arg.Any<CancellationToken>());
    }

    [Fact]
    public async Task RegisterToolsFromConfig_ToolHandler_ReturnsFailureOnNonZeroExit()
    {
        // Arrange
        ToolDefinition? capturedTool = null;
        var registry = Substitute.For<IToolRegistry>();
        registry.When(r => r.RegisterTool(Arg.Any<ToolDefinition>()))
            .Do(ci => capturedTool = ci.Arg<ToolDefinition>());
        var processRunner = Substitute.For<IProcessRunner>();
        processRunner.RunAsync(
            Arg.Any<string>(),
            Arg.Any<string[]>(),
            Arg.Any<ProcessOptions>(),
            Arg.Any<CancellationToken>())
            .Returns(Task.FromResult(new ProcessResult
            {
                ExitCode = 1,
                StandardOutput = string.Empty,
                StandardError = "Error: File not found"
            }));
        var config = new LanguageConfig
        {
            Language = new LanguageMetadata { Id = "python", Name = "Python" },
            Tools = new Dictionary<string, ToolConfig>
            {
                ["format"] = new ToolConfig
                {
                    Id = "python_format",
                    Command = "black"
                }
            }
        };
        var logger = NullLogger.Instance;

        // Act
        LanguageToolFactory.RegisterToolsFromConfig(registry, processRunner, config, logger);
        var input = new ToolInput { ToolId = "python_format" };
        var result = await capturedTool!.Handler(input, CancellationToken.None);

        // Assert
        result.Success.Should().BeFalse();
        result.Error.Should().Contain("Error: File not found");
    }

    [Fact]
    public async Task RegisterToolsFromConfig_WithFallback_TriesFallbackOnFailure()
    {
        // Arrange
        ToolDefinition? capturedTool = null;
        var registry = Substitute.For<IToolRegistry>();
        registry.When(r => r.RegisterTool(Arg.Any<ToolDefinition>()))
            .Do(ci => capturedTool = ci.Arg<ToolDefinition>());
        var processRunner = Substitute.For<IProcessRunner>();

        // Primary command fails
        processRunner.RunAsync(
            "black",
            Arg.Any<string[]>(),
            Arg.Any<ProcessOptions>(),
            Arg.Any<CancellationToken>())
            .Returns(Task.FromResult(new ProcessResult
            {
                ExitCode = 1,
                StandardOutput = string.Empty,
                StandardError = "black not found"
            }));

        // Fallback succeeds
        processRunner.RunAsync(
            "autopep8",
            Arg.Any<string[]>(),
            Arg.Any<ProcessOptions>(),
            Arg.Any<CancellationToken>())
            .Returns(Task.FromResult(new ProcessResult
            {
                ExitCode = 0,
                StandardOutput = "Formatted with autopep8",
                StandardError = string.Empty
            }));

        var config = new LanguageConfig
        {
            Language = new LanguageMetadata { Id = "python", Name = "Python" },
            Tools = new Dictionary<string, ToolConfig>
            {
                ["format"] = new ToolConfig
                {
                    Id = "python_format",
                    Command = "black",
                    Fallback = new FallbackConfig
                    {
                        Command = "autopep8",
                        Args = ["--in-place"]
                    }
                }
            }
        };
        var logger = NullLogger.Instance;

        // Act
        LanguageToolFactory.RegisterToolsFromConfig(registry, processRunner, config, logger);
        var input = new ToolInput { ToolId = "python_format" };
        var result = await capturedTool!.Handler(input, CancellationToken.None);

        // Assert
        result.Success.Should().BeTrue();
        await processRunner.Received(1).RunAsync(
            "autopep8",
            Arg.Any<string[]>(),
            Arg.Any<ProcessOptions>(),
            Arg.Any<CancellationToken>());
    }

    [Fact]
    public void RegisterToolsFromConfig_WithPathArg_GeneratesSchemaWithPathProperty()
    {
        // Arrange
        ToolDefinition? capturedTool = null;
        var registry = Substitute.For<IToolRegistry>();
        registry.When(r => r.RegisterTool(Arg.Any<ToolDefinition>()))
            .Do(ci => capturedTool = ci.Arg<ToolDefinition>());
        var processRunner = Substitute.For<IProcessRunner>();
        var config = new LanguageConfig
        {
            Language = new LanguageMetadata { Id = "python", Name = "Python" },
            Tools = new Dictionary<string, ToolConfig>
            {
                ["format"] = new ToolConfig
                {
                    Id = "python_format",
                    Command = "black",
                    PathArg = -1 // Append path at end
                }
            }
        };
        var logger = NullLogger.Instance;

        // Act
        LanguageToolFactory.RegisterToolsFromConfig(registry, processRunner, config, logger);

        // Assert
        capturedTool.Should().NotBeNull();
        capturedTool!.InputSchema.Should().Contain("path");
    }

    [Fact]
    public void RegisterToolsFromConfig_WithConfigArg_GeneratesSchemaWithConfigurationProperty()
    {
        // Arrange
        ToolDefinition? capturedTool = null;
        var registry = Substitute.For<IToolRegistry>();
        registry.When(r => r.RegisterTool(Arg.Any<ToolDefinition>()))
            .Do(ci => capturedTool = ci.Arg<ToolDefinition>());
        var processRunner = Substitute.For<IProcessRunner>();
        var config = new LanguageConfig
        {
            Language = new LanguageMetadata { Id = "csharp", Name = "C#" },
            Tools = new Dictionary<string, ToolConfig>
            {
                ["build"] = new ToolConfig
                {
                    Id = "dotnet_build",
                    Command = "dotnet",
                    Args = ["build"],
                    ConfigArg = ["-c"]
                }
            }
        };
        var logger = NullLogger.Instance;

        // Act
        LanguageToolFactory.RegisterToolsFromConfig(registry, processRunner, config, logger);

        // Assert
        capturedTool.Should().NotBeNull();
        capturedTool!.InputSchema.Should().Contain("configuration");
    }
}
