// <auto-generated>
// This file was generated by Aura Test Generator.
// </auto-generated>

#nullable enable

namespace Aura.Module.Developer.Guardians.Tests;

using System.IO.Abstractions;
using System.IO.Abstractions.TestingHelpers;
using Aura.Foundation.Guardians;
using Aura.Module.Developer.Guardians;
using FluentAssertions;
using Microsoft.Extensions.Logging.Abstractions;
using NSubstitute;
using Xunit;

/// <summary>
/// Helper class to create a MockFileSystem with a mocked FileSystemWatcher.
/// </summary>
internal sealed class TestableFileSystem : IFileSystem
{
    private readonly MockFileSystem _inner = new();
    private readonly IFileSystemWatcherFactory _watcherFactory;

    public TestableFileSystem(IFileSystemWatcherFactory watcherFactory)
    {
        _watcherFactory = watcherFactory;
    }

    public IDirectory Directory => _inner.Directory;
    public IDirectoryInfoFactory DirectoryInfo => _inner.DirectoryInfo;
    public IDriveInfoFactory DriveInfo => _inner.DriveInfo;
    public IFile File => _inner.File;
    public IFileInfoFactory FileInfo => _inner.FileInfo;
    public IFileStreamFactory FileStream => _inner.FileStream;
    public IFileSystemWatcherFactory FileSystemWatcher => _watcherFactory;
    public IPath Path => _inner.Path;

    public void AddDirectory(string path) => _inner.AddDirectory(path);
    public void AddFile(string path, MockFileData data) => _inner.AddFile(path, data);
    public void RemoveFile(string path) => _inner.RemoveFile(path);
}

public class GuardianRegistryTests : IDisposable
{
    private readonly TestableFileSystem _fileSystem;
    private readonly IFileSystemWatcherFactory _mockWatcherFactory;
    private readonly GuardianRegistry _sut;

    public GuardianRegistryTests()
    {
        // Mock the FileSystemWatcherFactory to avoid NotImplementedException
        _mockWatcherFactory = Substitute.For<IFileSystemWatcherFactory>();
        var mockWatcher = Substitute.For<IFileSystemWatcher>();
        _mockWatcherFactory.New(Arg.Any<string>(), Arg.Any<string>()).Returns(mockWatcher);
        _mockWatcherFactory.New(Arg.Any<string>()).Returns(mockWatcher);

        // Testable file system with mocked watcher
        _fileSystem = new TestableFileSystem(_mockWatcherFactory);

        _sut = new GuardianRegistry(_fileSystem, NullLogger<GuardianRegistry>.Instance);
    }

    public void Dispose()
    {
        _sut.Dispose();
        GC.SuppressFinalize(this);
    }

    [Fact]
    public void GetGuardian_WithNoGuardians_ReturnsNull()
    {
        // Act
        var result = _sut.GetGuardian("nonexistent");

        // Assert
        result.Should().BeNull();
    }

    [Fact]
    public void GetByTriggerType_WithNoGuardians_ReturnsEmpty()
    {
        // Act
        var result = _sut.GetByTriggerType(GuardianTriggerType.Schedule);

        // Assert
        result.Should().BeEmpty();
    }

    [Fact]
    public void Dispose_CanBeCalledMultipleTimes()
    {
        // Act
        _sut.Dispose();
        var act = () => _sut.Dispose();

        // Assert
        act.Should().NotThrow();
    }

    [Fact]
    public async Task ReloadAsync_WithNoDirectories_CompletesSuccessfully()
    {
        // Act
        await _sut.ReloadAsync();

        // Assert
        _sut.Guardians.Should().BeEmpty();
    }

    [Fact]
    public void AddWatchDirectory_WithNonExistentDirectory_DoesNotThrow()
    {
        // Act
        var act = () => _sut.AddWatchDirectory("/nonexistent/directory");

        // Assert
        act.Should().NotThrow();
    }

    [Fact]
    public void AddWatchDirectory_WithExistingDirectory_CreatesWatcher()
    {
        // Arrange
        var guardiansDir = "/guardians";
        _fileSystem.AddDirectory(guardiansDir);

        // Act
        _sut.AddWatchDirectory(guardiansDir);

        // Assert - verify watcher factory was called
        _mockWatcherFactory.Received(1).New(guardiansDir, "*.yaml");
    }

    [Fact]
    public void AddWatchDirectory_WithDuplicateDirectory_OnlyCreatesOneWatcher()
    {
        // Arrange
        var guardiansDir = "/guardians";
        _fileSystem.AddDirectory(guardiansDir);

        // Act
        _sut.AddWatchDirectory(guardiansDir);
        _sut.AddWatchDirectory(guardiansDir);
        _sut.AddWatchDirectory(guardiansDir);

        // Assert - watcher should only be created once
        _mockWatcherFactory.Received(1).New(guardiansDir, "*.yaml");
    }

    [Fact]
    public async Task ReloadAsync_WithEmptyDirectory_LoadsNoGuardians()
    {
        // Arrange
        var guardiansDir = "/guardians";
        _fileSystem.AddDirectory(guardiansDir);
        _sut.AddWatchDirectory(guardiansDir);

        // Act
        await _sut.ReloadAsync();

        // Assert
        _sut.Guardians.Should().BeEmpty();
    }

    [Fact]
    public async Task ReloadAsync_WithInvalidYaml_HandlesGracefully()
    {
        // Arrange
        var guardiansDir = "/guardians";
        _fileSystem.AddDirectory(guardiansDir);
        _fileSystem.AddFile($"{guardiansDir}/invalid.yaml", new MockFileData("this is not valid yaml: ["));
        _sut.AddWatchDirectory(guardiansDir);

        // Act & Assert - should not throw
        var act = async () => await _sut.ReloadAsync();
        await act.Should().NotThrowAsync();
        _sut.Guardians.Should().BeEmpty();
    }

    [Fact]
    public void Guardians_InitialState_IsEmpty()
    {
        // Assert
        _sut.Guardians.Should().NotBeNull();
        _sut.Guardians.Should().BeEmpty();
    }

    [Fact]
    public void GetByTriggerType_ForAllTriggerTypes_ReturnsEmptyForNewRegistry()
    {
        // Act & Assert
        _sut.GetByTriggerType(GuardianTriggerType.Schedule).Should().BeEmpty();
        _sut.GetByTriggerType(GuardianTriggerType.FileChanged).Should().BeEmpty();
        _sut.GetByTriggerType(GuardianTriggerType.Webhook).Should().BeEmpty();
    }
}
